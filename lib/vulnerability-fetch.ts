/**
 * Multi-Source Vulnerability Ingestion System
 * Supports fetching from multiple vulnerability databases and security advisories
 * 
 * @version 2.0
 * @author SecForIT SRL
 * @description Enhanced with NVD API 2.0 best practices, rate limiting, and multi-source orchestration
 */

export interface VulnerabilitySource {
  name: string;
  enabled: boolean;
  fetchFunction: () => Promise<VulnerabilityData[]>;
  priority: number; // Higher priority sources shown first
  requiresAuth?: boolean;
  description?: string;
}

export interface VulnerabilityData {
  id: string;
  title: string;
  description: string;
  severity: string;
  published: string;
  updated?: string;
  source: string;
  link: string;
  cveId?: string;
  cvssScore?: number;
  cvssVector?: string;
  product?: string;
  vendor?: string;
  dueDate?: string;
  tags?: string[];
  isKev?: boolean; // CISA Known Exploited Vulnerability flag
  cweId?: string;
}

export interface FetchStats {
  vulnerabilities: VulnerabilityData[];
  sourceStats: Record<string, number>;
  errors: string[];
  timestamp: string;
  totalResults: number;
}

const USER_AGENT = 'SecForIT-VulnerabilityTracker/2.0 (https://secforit.ro)';
const CACHE_REVALIDATION = 1800; // 30 minutes

/**
 * =============================================================================
 * NVD API CONFIGURATION & RATE LIMITING
 * =============================================================================
 */

// NVD API Configuration
const NVD_API_KEY = process.env.NVD_API_KEY;
const NVD_RATE_LIMIT_DELAY = NVD_API_KEY ? 600 : 6000; // 600ms with key (100/min), 6s without (5/30s)
const NVD_MAX_DATE_RANGE_DAYS = 120; // API maximum per documentation
const NVD_MAX_RESULTS_PER_PAGE = 2000; // API maximum

/**
 * Rate limiter for NVD API requests
 * Without API key: 5 requests per 30 seconds
 * With API key: 50 requests per 30 seconds (rate: ~100/min with sleep)
 */
let lastNvdRequest = 0;
async function nvdRateLimit(): Promise<void> {
  const now = Date.now();
  const timeSinceLastRequest = now - lastNvdRequest;
  
  if (timeSinceLastRequest < NVD_RATE_LIMIT_DELAY) {
    const waitTime = NVD_RATE_LIMIT_DELAY - timeSinceLastRequest;
    await new Promise(resolve => setTimeout(resolve, waitTime));
  }
  
  lastNvdRequest = Date.now();
}

/**
 * Build NVD API headers with optional API key
 */
function getNvdHeaders(): HeadersInit {
  const headers: HeadersInit = {
    'User-Agent': USER_AGENT
  };
  
  if (NVD_API_KEY) {
    headers['apiKey'] = NVD_API_KEY;
  }
  
  return headers;
}

/**
 * =============================================================================
 * CORE SOURCES: CISA KEV & NVD
 * =============================================================================
 */

/**
 * Fetch CISA Known Exploited Vulnerabilities
 * Priority: HIGHEST (actively exploited in the wild)
 * 
 * @param limit - Maximum number of vulnerabilities to return
 * @returns Array of vulnerability data
 */
export async function fetchCISAKEV(limit: number = 20): Promise<VulnerabilityData[]> {
  try {
    const response = await fetch(
      'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
      {
        next: { revalidate: CACHE_REVALIDATION },
        headers: { 'User-Agent': USER_AGENT }
      }
    );

    if (!response.ok) {
      throw new Error(`CISA API returned ${response.status}`);
    }

    const data = await response.json();
    
    return data.vulnerabilities
      ?.slice(0, limit)
      .map((vuln: any) => ({
        id: vuln.cveID || `cisa-${Date.now()}-${Math.random()}`,
        title: vuln.vulnerabilityName || 'Unknown Vulnerability',
        description: vuln.shortDescription || 'No description available',
        severity: 'Critical', // All KEV are considered critical by default
        published: vuln.dateAdded,
        updated: vuln.dateAdded,
        source: 'CISA KEV',
        link: `https://nvd.nist.gov/vuln/detail/${vuln.cveID}`,
        cveId: vuln.cveID,
        product: vuln.product,
        vendor: vuln.vendorProject,
        dueDate: vuln.dueDate,
        tags: ['actively-exploited', 'cisa-kev', 'critical'],
        isKev: true
      })) || [];
  } catch (error) {
    console.error('Error fetching CISA KEV:', error);
    return [];
  }
}

/**
 * Fetch recent NVD vulnerabilities with date filtering
 * Note: Maximum date range is 120 days per NVD API specification
 * 
 * @param daysBack - Number of days to look back (max 120)
 * @param limit - Maximum number of results (max 2000)
 * @param minCVSS - Minimum CVSS score filter (optional)
 * @param onlyKev - Only return vulnerabilities in CISA KEV catalog
 * @returns Array of vulnerability data
 */
export async function fetchNVDRecent(
  daysBack: number = 30,
  limit: number = 20,
  minCVSS?: number,
  onlyKev: boolean = false
): Promise<VulnerabilityData[]> {
  try {
    // Enforce API maximum date range
    if (daysBack > NVD_MAX_DATE_RANGE_DAYS) {
      console.warn(
        `Date range ${daysBack} exceeds NVD API maximum of ${NVD_MAX_DATE_RANGE_DAYS} days. ` +
        `Limiting to ${NVD_MAX_DATE_RANGE_DAYS} days.`
      );
      daysBack = NVD_MAX_DATE_RANGE_DAYS;
    }

    // Rate limiting compliance
    await nvdRateLimit();

    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysBack);

    const pubStartDate = startDate.toISOString();
    const pubEndDate = endDate.toISOString();

    // Enforce maximum results per page
    const resultsPerPage = Math.min(limit, NVD_MAX_RESULTS_PER_PAGE);

    let url = `https://services.nvd.nist.gov/rest/json/cves/2.0?` +
      `resultsPerPage=${resultsPerPage}&` +
      `pubStartDate=${pubStartDate}&` +
      `pubEndDate=${pubEndDate}`;
    
    // Add optional filters
    if (onlyKev) {
      url += '&hasKev';
    }
    
    // Optionally exclude rejected CVEs for cleaner results
    url += '&noRejected';

    const response = await fetch(url, {
      next: { revalidate: CACHE_REVALIDATION },
      headers: getNvdHeaders()
    });

    if (!response.ok) {
      throw new Error(`NVD API returned ${response.status}`);
    }

    const data = await response.json();

    const vulnerabilities = data.vulnerabilities
      ?.map((item: any) => {
        const vuln = item.cve;
        const description = vuln.descriptions?.find((d: any) => d.lang === 'en')?.value || 
          'No description available';
        
        // CVSS Score extraction (prioritize v3.1 > v3.0 > v2.0)
        const cvssMetricV31 = vuln.metrics?.cvssMetricV31?.[0];
        const cvssMetricV30 = vuln.metrics?.cvssMetricV30?.[0];
        const cvssMetricV2 = vuln.metrics?.cvssMetricV2?.[0];
        
        const cvssScore = 
          cvssMetricV31?.cvssData?.baseScore ||
          cvssMetricV30?.cvssData?.baseScore ||
          cvssMetricV2?.cvssData?.baseScore;

        const cvssVector = 
          cvssMetricV31?.cvssData?.vectorString ||
          cvssMetricV30?.cvssData?.vectorString ||
          cvssMetricV2?.cvssData?.vectorString;

        // Determine severity based on CVSS score
        let severity = 'Low';
        if (cvssScore) {
          if (cvssScore >= 9.0) severity = 'Critical';
          else if (cvssScore >= 7.0) severity = 'High';
          else if (cvssScore >= 4.0) severity = 'Medium';
        }

        // Check if in CISA KEV catalog
        const isKev = !!vuln.cisaExploitAdd;
        
        // Extract CWE information
        const cweId = vuln.weaknesses?.[0]?.description?.[0]?.value;

        const tags = ['nvd'];
        if (isKev) tags.push('cisa-kev', 'actively-exploited');
        if (cvssScore && cvssScore >= 9.0) tags.push('critical');
        if (cvssScore && cvssScore >= 7.0) tags.push('high');

        return {
          id: vuln.id,
          title: vuln.id,
          description,
          severity,
          published: vuln.published,
          updated: vuln.lastModified,
          source: 'NVD',
          link: `https://nvd.nist.gov/vuln/detail/${vuln.id}`,
          cveId: vuln.id,
          cvssScore,
          cvssVector,
          cweId,
          tags,
          isKev
        };
      }) || [];

    // Filter by minimum CVSS if specified
    if (minCVSS !== undefined) {
      return vulnerabilities.filter((v: VulnerabilityData) => 
        v.cvssScore && v.cvssScore >= minCVSS
      );
    }

    return vulnerabilities;
  } catch (error) {
    console.error('Error fetching NVD vulnerabilities:', error);
    return [];
  }
}

/**
 * Fetch NVD vulnerabilities by specific CVE IDs
 * Useful for getting detailed info on specific CVEs
 * 
 * @param cveIds - Array of CVE IDs (e.g., ['CVE-2024-1234', 'CVE-2024-5678'])
 * @returns Array of vulnerability data
 */
export async function fetchNVDByCVEIds(
  cveIds: string[]
): Promise<VulnerabilityData[]> {
  const vulnerabilities: VulnerabilityData[] = [];
  
  for (const cveId of cveIds) {
    try {
      await nvdRateLimit();
      
      const response = await fetch(
        `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`,
        {
          headers: getNvdHeaders(),
          next: { revalidate: 3600 }
        }
      );

      if (!response.ok) {
        console.warn(`Failed to fetch ${cveId}: ${response.status}`);
        continue;
      }

      const data = await response.json();
      const vuln = data.vulnerabilities?.[0]?.cve;
      
      if (!vuln) {
        console.warn(`No data found for ${cveId}`);
        continue;
      }

      const description = vuln.descriptions?.find((d: any) => d.lang === 'en')?.value || 
        'No description available';
      
      const cvssMetricV31 = vuln.metrics?.cvssMetricV31?.[0];
      const cvssMetricV30 = vuln.metrics?.cvssMetricV30?.[0];
      const cvssMetricV2 = vuln.metrics?.cvssMetricV2?.[0];
      
      const cvssScore = 
        cvssMetricV31?.cvssData?.baseScore ||
        cvssMetricV30?.cvssData?.baseScore ||
        cvssMetricV2?.cvssData?.baseScore;

      const cvssVector = 
        cvssMetricV31?.cvssData?.vectorString ||
        cvssMetricV30?.cvssData?.vectorString ||
        cvssMetricV2?.cvssData?.vectorString;

      let severity = 'Low';
      if (cvssScore) {
        if (cvssScore >= 9.0) severity = 'Critical';
        else if (cvssScore >= 7.0) severity = 'High';
        else if (cvssScore >= 4.0) severity = 'Medium';
      }

      const isKev = !!vuln.cisaExploitAdd;
      const cweId = vuln.weaknesses?.[0]?.description?.[0]?.value;

      const tags = ['nvd'];
      if (isKev) tags.push('cisa-kev', 'actively-exploited');

      vulnerabilities.push({
        id: vuln.id,
        title: vuln.id,
        description,
        severity,
        published: vuln.published,
        updated: vuln.lastModified,
        source: 'NVD',
        link: `https://nvd.nist.gov/vuln/detail/${vuln.id}`,
        cveId: vuln.id,
        cvssScore,
        cvssVector,
        cweId,
        tags,
        isKev
      });
    } catch (error) {
      console.error(`Error fetching ${cveId}:`, error);
    }
  }
  
  return vulnerabilities;
}

/**
 * Fetch NVD vulnerabilities by CPE (Common Platform Enumeration)
 * Useful for finding vulnerabilities affecting specific products
 * 
 * @param cpeName - CPE name (e.g., 'cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:*:*')
 * @param limit - Maximum number of results
 * @param onlyVulnerable - Only return CPEs marked as vulnerable
 * @returns Array of vulnerability data
 */
export async function fetchNVDByCPE(
  cpeName: string,
  limit: number = 20,
  onlyVulnerable: boolean = true
): Promise<VulnerabilityData[]> {
  try {
    await nvdRateLimit();

    const resultsPerPage = Math.min(limit, NVD_MAX_RESULTS_PER_PAGE);
    let url = `https://services.nvd.nist.gov/rest/json/cves/2.0?` +
      `cpeName=${encodeURIComponent(cpeName)}&` +
      `resultsPerPage=${resultsPerPage}`;
    
    if (onlyVulnerable) {
      url += '&isVulnerable';
    }

    const response = await fetch(url, {
      headers: getNvdHeaders(),
      next: { revalidate: CACHE_REVALIDATION }
    });

    if (!response.ok) {
      throw new Error(`NVD API returned ${response.status}`);
    }

    const data = await response.json();

    return data.vulnerabilities?.map((item: any) => {
      const vuln = item.cve;
      const description = vuln.descriptions?.find((d: any) => d.lang === 'en')?.value || 
        'No description available';
      
      const cvssScore = 
        vuln.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
        vuln.metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore ||
        vuln.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore;

      let severity = 'Low';
      if (cvssScore) {
        if (cvssScore >= 9.0) severity = 'Critical';
        else if (cvssScore >= 7.0) severity = 'High';
        else if (cvssScore >= 4.0) severity = 'Medium';
      }

      return {
        id: vuln.id,
        title: vuln.id,
        description,
        severity,
        published: vuln.published,
        updated: vuln.lastModified,
        source: 'NVD',
        link: `https://nvd.nist.gov/vuln/detail/${vuln.id}`,
        cveId: vuln.id,
        cvssScore,
        tags: ['nvd', 'cpe-match']
      };
    }) || [];
  } catch (error) {
    console.error('Error fetching NVD by CPE:', error);
    return [];
  }
}

/**
 * Fetch NVD vulnerabilities by CWE (Common Weakness Enumeration)
 * 
 * @param cweId - CWE identifier (e.g., 'CWE-79', 'CWE-89')
 * @param limit - Maximum number of results
 * @returns Array of vulnerability data
 */
export async function fetchNVDByCWE(
  cweId: string,
  limit: number = 20
): Promise<VulnerabilityData[]> {
  try {
    await nvdRateLimit();

    const resultsPerPage = Math.min(limit, NVD_MAX_RESULTS_PER_PAGE);
    const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?` +
      `cweId=${cweId}&` +
      `resultsPerPage=${resultsPerPage}`;

    const response = await fetch(url, {
      headers: getNvdHeaders(),
      next: { revalidate: CACHE_REVALIDATION }
    });

    if (!response.ok) {
      throw new Error(`NVD API returned ${response.status}`);
    }

    const data = await response.json();

    return data.vulnerabilities?.map((item: any) => {
      const vuln = item.cve;
      const description = vuln.descriptions?.find((d: any) => d.lang === 'en')?.value || 
        'No description available';
      
      const cvssScore = 
        vuln.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
        vuln.metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore ||
        vuln.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore;

      let severity = 'Low';
      if (cvssScore) {
        if (cvssScore >= 9.0) severity = 'Critical';
        else if (cvssScore >= 7.0) severity = 'High';
        else if (cvssScore >= 4.0) severity = 'Medium';
      }

      return {
        id: vuln.id,
        title: vuln.id,
        description,
        severity,
        published: vuln.published,
        updated: vuln.lastModified,
        source: 'NVD',
        link: `https://nvd.nist.gov/vuln/detail/${vuln.id}`,
        cveId: vuln.id,
        cvssScore,
        cweId,
        tags: ['nvd', cweId.toLowerCase()]
      };
    }) || [];
  } catch (error) {
    console.error(`Error fetching NVD by CWE ${cweId}:`, error);
    return [];
  }
}

/**
 * =============================================================================
 * ADDITIONAL SOURCES: GitHub, OSV, Snyk
 * =============================================================================
 */

/**
 * Fetch from GitHub Security Advisories
 * Note: Requires GitHub API token for higher rate limits (5000/hour vs 60/hour)
 * 
 * @param limit - Maximum number of advisories to fetch
 * @returns Array of vulnerability data
 */
export async function fetchGitHubAdvisories(limit: number = 20): Promise<VulnerabilityData[]> {
  try {
    const apiToken = process.env.GITHUB_API_TOKEN;
    const headers: HeadersInit = {
      'User-Agent': USER_AGENT,
      'Accept': 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28'
    };
    
    if (apiToken) {
      headers['Authorization'] = `Bearer ${apiToken}`;
    }

    // GitHub Security Advisory API
    const response = await fetch(
      `https://api.github.com/advisories?per_page=${limit}&sort=published&direction=desc`,
      {
        headers,
        next: { revalidate: CACHE_REVALIDATION }
      }
    );

    if (!response.ok) {
      console.warn(`GitHub API returned ${response.status}`);
      return [];
    }

    const advisories = await response.json();

    return advisories.map((advisory: any) => {
      // Map GitHub severity to standard severity levels
      let severity = advisory.severity?.toUpperCase() || 'Unknown';
      if (severity === 'MODERATE') severity = 'Medium';

      return {
        id: advisory.ghsa_id,
        title: advisory.summary,
        description: advisory.description || 'No description available',
        severity,
        published: advisory.published_at,
        updated: advisory.updated_at,
        source: 'GitHub Security Advisory',
        link: advisory.html_url,
        cveId: advisory.cve_id,
        cvssScore: advisory.cvss?.score,
        tags: ['github', ...(advisory.cve_id ? ['cve'] : []), ...(advisory.cwes?.map((cwe: any) => cwe.cwe_id.toLowerCase()) || [])]
      };
    });
  } catch (error) {
    console.error('Error fetching GitHub advisories:', error);
    return [];
  }
}

/**
 * Fetch from OSV (Open Source Vulnerabilities)
 * Covers npm, PyPI, Go, Rust, Maven, NuGet, and more
 * 
 * @param ecosystem - Package ecosystem (npm, PyPI, Go, Maven, etc.)
 * @param limit - Maximum number of vulnerabilities
 * @returns Array of vulnerability data
 */
export async function fetchOSVVulnerabilities(
  ecosystem: string = 'npm',
  limit: number = 20
): Promise<VulnerabilityData[]> {
  try {
    // OSV.dev API - query recent vulnerabilities
    const response = await fetch('https://api.osv.dev/v1/query', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': USER_AGENT
      },
      body: JSON.stringify({
        package: {
          ecosystem
        }
      }),
      next: { revalidate: CACHE_REVALIDATION }
    });

    if (!response.ok) {
      console.warn(`OSV API returned ${response.status}`);
      return [];
    }

    const data = await response.json();
    const vulns = (data.vulns || []).slice(0, limit);

    return vulns.map((vuln: any) => {
      // Map OSV severity to standard levels
      let severity = vuln.database_specific?.severity || 
        vuln.severity?.[0]?.type || 'Unknown';
      
      if (typeof severity === 'string') {
        severity = severity.toUpperCase();
        if (severity === 'MODERATE') severity = 'Medium';
      }

      // Extract CVSS score if available
      const cvssScore = vuln.severity?.find((s: any) => 
        s.type === 'CVSS_V3' || s.type === 'CVSS_V2'
      )?.score;

      return {
        id: vuln.id,
        title: vuln.summary || vuln.id,
        description: vuln.details || 'No description available',
        severity: typeof severity === 'string' ? severity : 'Unknown',
        published: vuln.published,
        updated: vuln.modified,
        source: `OSV (${ecosystem})`,
        link: `https://osv.dev/vulnerability/${vuln.id}`,
        cvssScore,
        tags: ['osv', ecosystem.toLowerCase()]
      };
    });
  } catch (error) {
    console.error(`Error fetching OSV ${ecosystem} vulnerabilities:`, error);
    return [];
  }
}

/**
 * Fetch from Snyk Vulnerability Database
 * Note: Requires Snyk API token
 * 
 * @param limit - Maximum number of vulnerabilities
 * @returns Array of vulnerability data
 */
export async function fetchSnykVulnerabilities(limit: number = 20): Promise<VulnerabilityData[]> {
  try {
    const apiToken = process.env.SNYK_API_TOKEN;
    if (!apiToken) {
      console.warn('Snyk API token not configured');
      return [];
    }

    // Note: Snyk API structure may vary - this is a generic implementation
    const response = await fetch(
      `https://api.snyk.io/v1/reporting/issues/latest?limit=${limit}`,
      {
        headers: {
          'Authorization': `token ${apiToken}`,
          'User-Agent': USER_AGENT
        },
        next: { revalidate: CACHE_REVALIDATION }
      }
    );

    if (!response.ok) {
      console.warn(`Snyk API returned ${response.status}`);
      return [];
    }

    const data = await response.json();
    const issues = data.results || data.vulnerabilities || [];

    return issues.slice(0, limit).map((vuln: any) => ({
      id: vuln.id || vuln.issueId,
      title: vuln.title || vuln.name,
      description: vuln.description || 'No description available',
      severity: vuln.severity || vuln.issueData?.severity || 'Unknown',
      published: vuln.publicationTime || vuln.disclosureTime,
      updated: vuln.modificationTime || vuln.publicationTime,
      source: 'Snyk',
      link: vuln.url || `https://security.snyk.io/vuln/${vuln.id}`,
      cvssScore: vuln.cvssScore || vuln.issueData?.cvssScore,
      tags: ['snyk']
    }));
  } catch (error) {
    console.error('Error fetching Snyk vulnerabilities:', error);
    return [];
  }
}

/**
 * =============================================================================
 * MULTI-SOURCE ORCHESTRATION
 * =============================================================================
 */

/**
 * Define all available sources with configuration
 */
export const VULNERABILITY_SOURCES: VulnerabilitySource[] = [
  {
    name: 'CISA KEV',
    enabled: true,
    fetchFunction: () => fetchCISAKEV(15),
    priority: 100,
    requiresAuth: false,
    description: 'Known Exploited Vulnerabilities actively exploited in the wild'
  },
  {
    name: 'NVD KEV Only',
    enabled: true,
    fetchFunction: () => fetchNVDRecent(30, 10, undefined, true),
    priority: 95,
    requiresAuth: false,
    description: 'NVD vulnerabilities that appear in CISA KEV catalog'
  },
  {
    name: 'NVD Recent (High+)',
    enabled: true,
    fetchFunction: () => fetchNVDRecent(30, 15, 7.0),
    priority: 90,
    requiresAuth: false,
    description: 'Recent high-severity vulnerabilities from NVD (CVSS >= 7.0)'
  },
  {
    name: 'NVD Recent (Critical)',
    enabled: true,
    fetchFunction: () => fetchNVDRecent(30, 10, 9.0),
    priority: 92,
    requiresAuth: false,
    description: 'Recent critical vulnerabilities from NVD (CVSS >= 9.0)'
  },
  {
    name: 'GitHub Advisories',
    enabled: !!process.env.GITHUB_API_TOKEN,
    fetchFunction: () => fetchGitHubAdvisories(10),
    priority: 80,
    requiresAuth: true,
    description: 'Security advisories from GitHub'
  },
  {
    name: 'OSV npm',
    enabled: true,
    fetchFunction: () => fetchOSVVulnerabilities('npm', 10),
    priority: 70,
    requiresAuth: false,
    description: 'npm package vulnerabilities from OSV'
  },
  {
    name: 'OSV PyPI',
    enabled: true,
    fetchFunction: () => fetchOSVVulnerabilities('PyPI', 10),
    priority: 70,
    requiresAuth: false,
    description: 'Python package vulnerabilities from OSV'
  },
  {
    name: 'OSV Go',
    enabled: false, // Disabled by default - enable as needed
    fetchFunction: () => fetchOSVVulnerabilities('Go', 10),
    priority: 70,
    requiresAuth: false,
    description: 'Go package vulnerabilities from OSV'
  },
  {
    name: 'OSV Maven',
    enabled: false, // Disabled by default - enable as needed
    fetchFunction: () => fetchOSVVulnerabilities('Maven', 10),
    priority: 70,
    requiresAuth: false,
    description: 'Maven package vulnerabilities from OSV'
  },
  {
    name: 'Snyk',
    enabled: !!process.env.SNYK_API_TOKEN,
    fetchFunction: () => fetchSnykVulnerabilities(10),
    priority: 75,
    requiresAuth: true,
    description: 'Vulnerabilities from Snyk database'
  }
];

/**
 * Fetch vulnerabilities from all enabled sources
 * 
 * @returns Object containing vulnerabilities, stats, and any errors
 */
export async function fetchFromAllSources(): Promise<FetchStats> {
  const enabledSources = VULNERABILITY_SOURCES.filter(s => s.enabled);
  
  console.log(`Fetching from ${enabledSources.length} enabled sources...`);
  
  const results = await Promise.allSettled(
    enabledSources.map(source => {
      console.log(`Fetching from ${source.name}...`);
      return source.fetchFunction();
    })
  );

  let allVulnerabilities: VulnerabilityData[] = [];
  const sourceStats: Record<string, number> = {};
  const errors: string[] = [];

  results.forEach((result, index) => {
    const sourceName = enabledSources[index].name;
    
    if (result.status === 'fulfilled') {
      const vulns = result.value;
      allVulnerabilities = [...allVulnerabilities, ...vulns];
      sourceStats[sourceName] = vulns.length;
      console.log(`✓ ${sourceName}: ${vulns.length} vulnerabilities`);
    } else {
      const error = `${sourceName}: ${result.reason}`;
      errors.push(error);
      sourceStats[sourceName] = 0;
      console.error(`✗ ${error}`);
    }
  });

  // Sort by priority source, then by published date (newest first)
  allVulnerabilities.sort((a, b) => {
    const sourceA = enabledSources.find(s => a.source.includes(s.name));
    const sourceB = enabledSources.find(s => b.source.includes(s.name));
    
    const priorityA = sourceA?.priority || 0;
    const priorityB = sourceB?.priority || 0;
    
    if (priorityA !== priorityB) {
      return priorityB - priorityA;
    }
    
    return new Date(b.published).getTime() - new Date(a.published).getTime();
  });

  // Remove duplicates based on CVE ID (keep highest priority source)
  const uniqueVulns = allVulnerabilities.filter((vuln, index, self) =>
    !vuln.cveId || index === self.findIndex(v => v.cveId === vuln.cveId)
  );

  console.log(`Total: ${uniqueVulns.length} unique vulnerabilities (${allVulnerabilities.length - uniqueVulns.length} duplicates removed)`);

  return {
    vulnerabilities: uniqueVulns,
    sourceStats,
    errors,
    timestamp: new Date().toISOString(),
    totalResults: uniqueVulns.length
  };
}

/**
 * Fetch with specific source configuration
 * 
 * @param sourceNames - Array of source names to fetch from
 * @returns Array of vulnerability data
 */
export async function fetchFromSources(
  sourceNames: string[]
): Promise<VulnerabilityData[]> {
  const sources = VULNERABILITY_SOURCES.filter(s => 
    s.enabled && sourceNames.includes(s.name)
  );

  if (sources.length === 0) {
    console.warn('No enabled sources match the provided names');
    return [];
  }

  console.log(`Fetching from ${sources.length} specified sources...`);

  const results = await Promise.allSettled(
    sources.map(source => source.fetchFunction())
  );

  const vulnerabilities: VulnerabilityData[] = [];

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      vulnerabilities.push(...result.value);
    } else {
      console.error(`Error fetching from ${sources[index].name}:`, result.reason);
    }
  });

  return vulnerabilities.sort((a, b) => 
    new Date(b.published).getTime() - new Date(a.published).getTime()
  );
}

/**
 * Backward compatibility - fetch CISA + NVD combined
 * 
 * @param cisaLimit - Maximum CISA vulnerabilities
 * @param nvdDaysBack - Days back for NVD search
 * @param nvdMinCVSS - Minimum CVSS score for NVD
 * @returns Array of vulnerability data
 */
export async function fetchCombinedVulnerabilities(
  cisaLimit: number = 10,
  nvdDaysBack: number = 30,
  nvdMinCVSS: number = 7.0
): Promise<VulnerabilityData[]> {
  const [cisaVulns, nvdVulns] = await Promise.all([
    fetchCISAKEV(cisaLimit),
    fetchNVDRecent(nvdDaysBack, 20, nvdMinCVSS)
  ]);

  const combined = [...cisaVulns, ...nvdVulns];
  
  // Remove duplicates based on CVE ID
  const unique = combined.filter((vuln, index, self) =>
    !vuln.cveId || index === self.findIndex(v => v.cveId === vuln.cveId)
  );

  return unique.sort((a, b) => 
    new Date(b.published).getTime() - new Date(a.published).getTime()
  );
}

/**
 * Alias exports for backward compatibility
 */
export const fetchCISAVulnerabilities = fetchCISAKEV;
export const fetchRecentNVDVulnerabilities = fetchNVDRecent;

/**
 * Get detailed CVE information from NVD
 * 
 * @param cveId - CVE identifier (e.g., 'CVE-2024-1234')
 * @returns Detailed CVE data or null
 */
export async function fetchCVEDetails(cveId: string): Promise<any> {
  try {
    await nvdRateLimit();
    
    const response = await fetch(
      `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`,
      {
        headers: getNvdHeaders(),
        next: { revalidate: 3600 } // Cache for 1 hour
      }
    );

    if (response.ok) {
      const data = await response.json();
      return data.vulnerabilities?.[0]?.cve || null;
    }
  } catch (error) {
    console.error(`Error fetching details for ${cveId}:`, error);
  }
  return null;
}

/**
 * =============================================================================
 * FILTERING & UTILITIES
 * =============================================================================
 */

/**
 * Filter vulnerabilities by severity levels
 * 
 * @param vulnerabilities - Array of vulnerabilities to filter
 * @param severities - Array of severity levels to include
 * @returns Filtered array
 */
export function filterBySeverity(
  vulnerabilities: VulnerabilityData[],
  severities: string[]
): VulnerabilityData[] {
  const normalizedSeverities = severities.map(s => s.toLowerCase());
  return vulnerabilities.filter(v => 
    normalizedSeverities.includes(v.severity.toLowerCase())
  );
}

/**
 * Filter vulnerabilities by source
 * 
 * @param vulnerabilities - Array of vulnerabilities to filter
 * @param sources - Array of source names to include
 * @returns Filtered array
 */
export function filterBySource(
  vulnerabilities: VulnerabilityData[],
  sources: string[]
): VulnerabilityData[] {
  return vulnerabilities.filter(v => 
    sources.some(source => v.source.includes(source))
  );
}

/**
 * Filter vulnerabilities by tags
 * 
 * @param vulnerabilities - Array of vulnerabilities to filter
 * @param tags - Array of tags to match (any)
 * @returns Filtered array
 */
export function filterByTags(
  vulnerabilities: VulnerabilityData[],
  tags: string[]
): VulnerabilityData[] {
  const normalizedTags = tags.map(t => t.toLowerCase());
  return vulnerabilities.filter(v => 
    v.tags?.some(tag => normalizedTags.includes(tag.toLowerCase()))
  );
}

/**
 * Filter vulnerabilities published within date range
 * 
 * @param vulnerabilities - Array of vulnerabilities to filter
 * @param startDate - Start date (ISO string or Date)
 * @param endDate - End date (ISO string or Date)
 * @returns Filtered array
 */
export function filterByDateRange(
  vulnerabilities: VulnerabilityData[],
  startDate: string | Date,
  endDate: string | Date
): VulnerabilityData[] {
  const start = new Date(startDate).getTime();
  const end = new Date(endDate).getTime();
  
  return vulnerabilities.filter(v => {
    const published = new Date(v.published).getTime();
    return published >= start && published <= end;
  });
}

/**
 * Get only CISA KEV vulnerabilities
 * 
 * @param vulnerabilities - Array of vulnerabilities to filter
 * @returns Array of KEV vulnerabilities
 */
export function filterKEVOnly(
  vulnerabilities: VulnerabilityData[]
): VulnerabilityData[] {
  return vulnerabilities.filter(v => v.isKev === true);
}

/**
 * Get vulnerability statistics
 * 
 * @param vulnerabilities - Array of vulnerabilities to analyze
 * @returns Statistics object
 */
export function getVulnerabilityStats(vulnerabilities: VulnerabilityData[]) {
  return {
    total: vulnerabilities.length,
    bySeverity: {
      critical: vulnerabilities.filter(v => v.severity === 'Critical').length,
      high: vulnerabilities.filter(v => v.severity === 'High').length,
      medium: vulnerabilities.filter(v => v.severity === 'Medium').length,
      low: vulnerabilities.filter(v => v.severity === 'Low').length,
      unknown: vulnerabilities.filter(v => !v.severity || v.severity === 'Unknown').length
    },
    bySource: vulnerabilities.reduce((acc, v) => {
      acc[v.source] = (acc[v.source] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    kevCount: vulnerabilities.filter(v => v.isKev).length,
    withCVSS: vulnerabilities.filter(v => v.cvssScore !== undefined).length,
    avgCVSS: vulnerabilities.reduce((sum, v) => sum + (v.cvssScore || 0), 0) / 
      vulnerabilities.filter(v => v.cvssScore).length || 0,
    dateRange: {
      oldest: vulnerabilities.reduce((oldest, v) => 
        new Date(v.published) < new Date(oldest.published) ? v : oldest
      , vulnerabilities[0])?.published,
      newest: vulnerabilities.reduce((newest, v) => 
        new Date(v.published) > new Date(newest.published) ? v : newest
      , vulnerabilities[0])?.published
    }
  };
}

/**
 * Sort vulnerabilities by various criteria
 * 
 * @param vulnerabilities - Array of vulnerabilities to sort
 * @param sortBy - Sort criteria
 * @param order - Sort order (asc/desc)
 * @returns Sorted array
 */
export function sortVulnerabilities(
  vulnerabilities: VulnerabilityData[],
  sortBy: 'published' | 'cvss' | 'severity' | 'source' = 'published',
  order: 'asc' | 'desc' = 'desc'
): VulnerabilityData[] {
  const sorted = [...vulnerabilities];
  
  sorted.sort((a, b) => {
    let comparison = 0;
    
    switch (sortBy) {
      case 'published':
        comparison = new Date(a.published).getTime() - new Date(b.published).getTime();
        break;
      case 'cvss':
        comparison = (a.cvssScore || 0) - (b.cvssScore || 0);
        break;
      case 'severity':
        const severityOrder: Record<string, number> = {
          'Critical': 4,
          'High': 3,
          'Medium': 2,
          'Low': 1,
          'Unknown': 0
        };
        comparison = (severityOrder[a.severity] || 0) - (severityOrder[b.severity] || 0);
        break;
      case 'source':
        comparison = a.source.localeCompare(b.source);
        break;
    }
    
    return order === 'asc' ? comparison : -comparison;
  });
  
  return sorted;
}

/**
 * Export vulnerabilities to JSON
 * 
 * @param vulnerabilities - Array of vulnerabilities
 * @param includeStats - Include statistics in export
 * @returns JSON string
 */
export function exportToJSON(
  vulnerabilities: VulnerabilityData[],
  includeStats: boolean = true
): string {
  const data: any = {
    timestamp: new Date().toISOString(),
    count: vulnerabilities.length,
    vulnerabilities
  };
  
  if (includeStats) {
    data.stats = getVulnerabilityStats(vulnerabilities);
  }
  
  return JSON.stringify(data, null, 2);
}

/**
 * Export vulnerabilities to CSV
 * 
 * @param vulnerabilities - Array of vulnerabilities
 * @returns CSV string
 */
export function exportToCSV(vulnerabilities: VulnerabilityData[]): string {
  const headers = [
    'CVE ID',
    'Title',
    'Severity',
    'CVSS Score',
    'Published',
    'Source',
    'Is KEV',
    'Description',
    'Link'
  ];
  
  const rows = vulnerabilities.map(v => [
    v.cveId || v.id,
    v.title,
    v.severity,
    v.cvssScore?.toString() || '',
    v.published,
    v.source,
    v.isKev ? 'Yes' : 'No',
    `"${v.description.replace(/"/g, '""')}"`,
    v.link
  ]);
  
  return [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n');
}

/**
 * =============================================================================
 * CONFIGURATION & HEALTH CHECK
 * =============================================================================
 */

/**
 * Check API configuration status
 * 
 * @returns Configuration status
 */
export function getAPIConfig() {
  return {
    nvd: {
      hasApiKey: !!NVD_API_KEY,
      rateLimit: NVD_API_KEY ? '50 requests/30s' : '5 requests/30s',
      maxDateRange: `${NVD_MAX_DATE_RANGE_DAYS} days`,
      maxResultsPerPage: NVD_MAX_RESULTS_PER_PAGE
    },
    github: {
      hasApiKey: !!process.env.GITHUB_API_TOKEN,
      enabled: !!process.env.GITHUB_API_TOKEN
    },
    snyk: {
      hasApiKey: !!process.env.SNYK_API_TOKEN,
      enabled: !!process.env.SNYK_API_TOKEN
    },
    sources: {
      total: VULNERABILITY_SOURCES.length,
      enabled: VULNERABILITY_SOURCES.filter(s => s.enabled).length,
      requireAuth: VULNERABILITY_SOURCES.filter(s => s.requiresAuth && !s.enabled).length
    }
  };
}

/**
 * List all available and enabled sources
 * 
 * @returns Array of source information
 */
export function listSources() {
  return VULNERABILITY_SOURCES.map(s => ({
    name: s.name,
    enabled: s.enabled,
    priority: s.priority,
    requiresAuth: s.requiresAuth || false,
    description: s.description
  }));
}